% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gurobi.R
\name{gurobi}
\alias{gurobi}
\title{Optimize a model}
\usage{
gurobi(model, params = NULL, env = NULL)
}
\arguments{
\item{model}{The model list must contain a valid Gurobi model. See
\code{\link{gurobi_model}} for more information.}

\item{params}{The params \code{list}, when provided, contains a list of
modified Gurobi parameters. See the \code{\link{gurobi_params}}
documentation for more details.}

\item{env}{The env list, when provided, allows you to use Gurobi Compute
Server or Gurobi Instant Cloud. See \code{\link{gurobi_env}} for more
information.}
}
\value{
a list with named components: see \link{The optimization result}.
}
\description{
This function optimizes the given model.  The algorithm used for the
optimization depends on the model type (simplex or barrier for a continuous
model; branch-and-cut for a MIP model).  Upon successful completion it will
return a \code{list} variable containing solution information.

Please consult c("(FIXME-MRhrefH: #1; #2; #3)", "this section",
"sec:VarsConstraintsObjectives", "variables_and_constraints")(FIXME-MRhrefH:
this section; sec:VarsConstraintsObjectives; variables_and_constraints) for
a discussion of some of the practical issues associated with solving a
precisely defined mathematical model using finite-precision floating-point
arithmetic.
}
\section{The optimization result}{


The c("\\code{\\link{#3}}", "gurobi", "r:gurobi",
"gurobi")\code{\link{gurobi}} function returns a \code{list}, with the
various results of the optimization stored in its named components. The
specific results that are available depend on the type of model that was
solved, the parameters used, and the status of the optimization. The
following is a list of named components that might be available in the
returned result.  We will discuss the circumstances under which each will be
available after presenting the list.
}

\section{Model named components}{


\itemize{ \item\link{status} The status of the optimization, returned as a
string. The desired result is \code{'OPTIMAL'}, which indicates that an
optimal solution to the model was found. Other status are possible, for
example if the model has no feasible solution or if you set a Gurobi
parameter that leads to early solver termination. See the c("(FIXME-MRhrefH:
#1; #2; #3)", "Status Code", "sec:StatusCodes",
"optimization_status_codes")(FIXME-MRhrefH: Status Code; sec:StatusCodes;
optimization_status_codes) section for further information on the Gurobi
status codes.

\item\link{objval} The objective value of the computed solution.  Note that for
multi-objective models \code{result$objval} will be a vector, where
\code{result$objvalc("[[#1]]", "i")[[i]]} stores the value for c("#1", " ")
\code{model$multiobjc("[[#1]]", "i")[[i]]}.

\item\link{objbound} Best available bound on solution (lower bound for
minimization, upper bound for maximization).

\item\link{objboundc} The best unrounded bound on the optimal objective. In
contrast to \code{objbound}, this attribute does not take advantage of
objective integrality information to round to a tighter bound.  For example,
if the objective is known to take an integral value and the current best
bound is 1.5, \code{ObjBound} will return 2.0 while \code{ObjBoundC} will
return 1.5.

\item\link{mipgap} Current relative MIP optimality gap; computed as \eqn{\vert
ObjBound-ObjVal\vert/\vert ObjVal\vert}{|ObjBound-ObjVal|/|ObjVal|} (where
\eqn{ObjBound}{ObjBound} and \eqn{ObjVal}{ObjVal} are the MIP objective
bound and incumbent solution objective, respectively). Returns
\code{GRB_INFINITY} when an incumbent solution has not yet been found, when
no objective bound is available, or when the current incumbent objective is
0.  This is only available for mixed-integer problems.

\item\link{runtime} The elapsed wall-clock time (in seconds) for the
optimization.

\item\link{itercount} Number of simplex iterations performed.

\item\link{baritercount} Number of barrier iterations performed.

\item\link{nodecount} Number of branch-and-cut nodes explored.

\item\link{farkasproof} Magnitude of infeasibility violation in Farkas
infeasibility proof. Only available if the model was found to be infeasible.
Please refer to c("(FIXME-MRhrefH: #1; #2; #3)", "FarkasProof",
"attr:FarkasProof", "farkasproof")(FIXME-MRhrefH: FarkasProof;
attr:FarkasProof; farkasproof) for details. }
}

\section{Variable named components}{


\itemize{ \item\link{x} The computed solution. This vector contains one entry for
each column of \code{A}.

\item\link{rc} Variable reduced costs for the computed solution. This vector
contains one entry for each column of \code{A}.

\item\link{vbasis} Variable basis status values for the computed optimal basis.
You generally should not concern yourself with the contents of this vector.
If you wish to use an advanced start later, you would simply copy the
\code{vbasis} and \code{cbasis} named components into the corresponding
named components for the next model. This vector contains one entry for each
column of \code{A}.

\item\link{unbdray} Unbounded ray. Provides a vector that, when added to any
feasible solution, yields a new solution that is also feasible but improves
the objective. Only available if the model is found to be unbounded.  This
vector contains one entry for each column of \code{A}. }
}

\section{Linear constraint named components}{


\itemize{ \item\link{slack} The constraint slack for the computed solution. This
vector contains one entry for each row of \code{A}.

\item\link{pi} Dual values for the computed solution (also known as \emph{shadow
prices}). This vector contains one entry for each row of \code{A}.

\item\link{cbasis} Constraint basis status values for the computed optimal basis.
This vector contains one entry for each row of \code{A}.

\item\link{farkasdual} Farkas infeasibility proof. Only available if the model
was found to be infeasible.  Please refer to c("(FIXME-MRhrefH: #1; #2;
#3)", "FarkasDual", "attr:FarkasDual", "farkasdual")(FIXME-MRhrefH:
FarkasDual; attr:FarkasDual; farkasdual) for details. }
}

\section{Quadratic constraint named components}{


\itemize{ \item\link{qcslack} The quadratic constraint slack in the current
solution.  This vector contains one entry for each quadratic constraint.

\item\link{qcpi} The dual values associated with the quadratic constraints.  This
vector contains one entry for each quadratic constraint. }
}

\section{Solution Pool named components}{


\itemize{
\item\link{pool} When multiple solutions are found during the
optimization call, these solutions are returned in this named component. A A
list of lists.  When present, each list has the following named components:
\itemize{ \item\link{objval} Stores the objective value of the \eqn{i}{i}-th
solution in \code{result$poolc("[[#1]]", "i")[[i]]$objval}. Note that when
the model is a multi-objective model, instead of a single value,
\code{result$pool{c("[[#1]]", "i")[[i]]}$objval{c("[#1]", "j")[j]}} stores
the value of the \eqn{j}{j}-th objective function for the \eqn{i}{i}-th
solution.

\item\link{xn} Stores the \eqn{i}{i}-th solution in \code{result$poolc("[[#1]]",
"i")[[i]]$xn}. This vector contains one entry for each column of \code{A}. }
Note that to query the number of solutions stored, you can query the length
of \code{result$pool}.

\item\link{poolobjbound} For single-objective MIP optimization problems, this
value gives a bound on the best possible objective of an undiscovered
solution.  The difference between this value and \code{objbound} is that the
former gives an objective bound for undiscovered solutions, while the latter
gives a bound for any solution.

}
}

\section{What is Available When}{


The \code{status} named component will be present in all cases. It indicates
whether Gurobi was able to find a proven optimal solution to the model. In
cases where a solution to the model was found, optimal or otherwise, the
\code{objval} and \code{x} named components will be present.

For linear and quadratic programs, if a solution is available, then the
\code{pi} and \code{rc} named components will also be present. For models
with quadratic constraints, if the parameter \code{qcpdual} is set to 1, the
named component \code{qcpi} will be present. If the final solution is a
\emph{basic} solution (computed by simplex), then \code{vbasis} and
\code{cbasis} will be present. If the model is an unbounded linear program
and the c("(FIXME-MRhrefH: #1; #2; #3)", "InfUnbdInfo",
"parameter:InfUnbdInfo", "infunbdinfo")(FIXME-MRhrefH: InfUnbdInfo;
parameter:InfUnbdInfo; infunbdinfo) parameter is set to 1, the named
component \code{unbdray} will be present. Finally, if the model is an
infeasible linear program and the c("(FIXME-MRhrefH: #1; #2; #3)",
"InfUnbdInfo", "parameter:InfUnbdInfo", "infunbdinfo")(FIXME-MRhrefH:
InfUnbdInfo; parameter:InfUnbdInfo; infunbdinfo) parameter is set to 1, the
named components \code{farkasdual} and \code{farkasproof} will be set.

For mixed integer problems, no dual information (i.e. \code{pi},
\code{slack}, \code{rc}, \code{vbasis}, \code{cbasis}, \code{qcslack},
\code{qcpi}, \code{ubdray} or \code{farkasdual}) is ever available. When
multiple solutions are found, the \code{pool} and \code{poolobjbound} named
components will be present. Depending on the \code{status} named component
value, the named components \code{nodecount}, \code{objbound},
\code{objbundc} and \code{mipgap} will be available.

For continuous and mixed-integer models, under normal execution, the named
components \code{runtime}, \code{itercount} and \code{baritercount} will be
available.
}

\examples{

result <- gurobi(model, params)
if (result$status == 'OPTIMAL') {
  print(result$objval)
  print(result$x)
} else {
  cat('Optimization returned status:', formatC(result$status), '\n')
}


}
\references{
Gurobi Optimization (\url{http://www.gurobi.com}).

Gurobi Optimizer Reference Manual
(\url{http://www.gurobi.com/documentation/9.0/refman/index.html}).
}
\seealso{
The \code{\link{gurobi_package}} documentation contains general
information on the Gurobi R interface. The \code{\link{gurobi_problem}}
documentation has a detailed description of the types of models that gurobi
is able to optimize. The \code{\link{gurobi_usage}} documentation has an
overview on the usage of the Gurobi package.

For a detailed description of variables used as input and output of gurobi
functions see \code{\link{gurobi_model}}, \code{\link{gurobi_params}} and
\code{\link{gurobi_env}}.

The functions provided by the Gurobi package are: \code{\link{gurobi}},
\code{\link{gurobi_iis}}, \code{\link{gurobi_feasrelax}},
\code{\link{gurobi_relax}}, \code{\link{gurobi_read}} and
\code{\link{gurobi_write}}.
}
\author{
Gurobi Optimization
}
\keyword{optimize}
